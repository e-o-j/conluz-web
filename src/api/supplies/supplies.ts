/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Conluz API
 * Conluz is an API-driven application designed for the efficient management of an energy community,enabling the administration of community members and their corresponding supply points and the retrieval of consumption, production data.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  CreateSuppliesInBulkResponse,
  CreateSuppliesWithFileBody,
  CreateSupplyBody,
  GetAllSuppliesParams,
  PagedResultSupplyResponse,
  SupplyResponse,
  UpdateSupplyBody
} from '.././models';





/**
 * This endpoint enables the update of supply information by specifying the supply's unique identifier in the endpoint path.

Clients send a request containing the updated supply details, and authentication, through an authentication token, is required for secure access.

A successful update results in an HTTP status code of 200, indicating that the supply information has been successfully modified. In cases where the update encounters errors, the server responds with an appropriate error status code along with a descriptive error message to assist clients in addressing and resolving the issue.

If you don't provide some of the optional parameters, they will be considered as null value so their values will be updated with a null value.
 * @summary Updates supply information
 */
export const updateSupply = (
    id: string,
    updateSupplyBody: UpdateSupplyBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SupplyResponse>> => {
    
    
    return axios.default.put(
      `/api/v1/supplies/${id}`,
      updateSupplyBody,options
    );
  }



export const getUpdateSupplyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSupply>>, TError,{id: string;data: UpdateSupplyBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateSupply>>, TError,{id: string;data: UpdateSupplyBody}, TContext> => {

const mutationKey = ['updateSupply'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSupply>>, {id: string;data: UpdateSupplyBody}> = (props) => {
          const {id,data} = props ?? {};

          return  updateSupply(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSupplyMutationResult = NonNullable<Awaited<ReturnType<typeof updateSupply>>>
    export type UpdateSupplyMutationBody = UpdateSupplyBody
    export type UpdateSupplyMutationError = AxiosError<unknown>

    /**
 * @summary Updates supply information
 */
export const useUpdateSupply = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSupply>>, TError,{id: string;data: UpdateSupplyBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSupply>>,
        TError,
        {id: string;data: UpdateSupplyBody},
        TContext
      > => {

      const mutationOptions = getUpdateSupplyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * This endpoint serves to retrieve all registered supplies within the system, supporting pagination, filtering, and sorting for a customized query experience. This endpoint requires authentication through a Bearer Token for secure access. Clients can include optional query parameters such as page to specify the page number, limit to determine supplies per page, filter to selectively retrieve supplies based on criteria, and sort to define the order of the results. A successful request yields a paginated list of supplies, providing essential details, while any authentication or retrieval issues prompt an appropriate error response. With its versatile functionality, this endpoint enhances the ability to explore and manage the array of energy supplies within the system.
 * @summary Retrieves all registered supplies in the system with support for pagination, filtering, and sorting.
 */
export const getAllSupplies = (
    params?: GetAllSuppliesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PagedResultSupplyResponse>> => {
    
    
    return axios.default.get(
      `/api/v1/supplies`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetAllSuppliesQueryKey = (params?: GetAllSuppliesParams,) => {
    return [`/api/v1/supplies`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllSuppliesQueryOptions = <TData = Awaited<ReturnType<typeof getAllSupplies>>, TError = AxiosError<unknown>>(params?: GetAllSuppliesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllSupplies>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllSuppliesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllSupplies>>> = ({ signal }) => getAllSupplies(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllSupplies>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllSuppliesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllSupplies>>>
export type GetAllSuppliesQueryError = AxiosError<unknown>


export function useGetAllSupplies<TData = Awaited<ReturnType<typeof getAllSupplies>>, TError = AxiosError<unknown>>(
 params: undefined |  GetAllSuppliesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllSupplies>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllSupplies>>,
          TError,
          Awaited<ReturnType<typeof getAllSupplies>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllSupplies<TData = Awaited<ReturnType<typeof getAllSupplies>>, TError = AxiosError<unknown>>(
 params?: GetAllSuppliesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllSupplies>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllSupplies>>,
          TError,
          Awaited<ReturnType<typeof getAllSupplies>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllSupplies<TData = Awaited<ReturnType<typeof getAllSupplies>>, TError = AxiosError<unknown>>(
 params?: GetAllSuppliesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllSupplies>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves all registered supplies in the system with support for pagination, filtering, and sorting.
 */

export function useGetAllSupplies<TData = Awaited<ReturnType<typeof getAllSupplies>>, TError = AxiosError<unknown>>(
 params?: GetAllSuppliesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllSupplies>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllSuppliesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * This endpoint is designed to create a new supply within the system. To utilize this endpoint, a client sends a request containing essential details such as the supply's address, partition coefficient, and any relevant parameters. Proper authentication, through authentication tokens, is required to access this endpoint. Upon successful creation, the server responds with a status code of 200, providing comprehensive details about the newly created supply, including its unique identifier. In case of failure, the server returns an appropriate error status code along with a descriptive error message, aiding the client in diagnosing and addressing the issue. This endpoint plays a pivotal role in dynamically expanding the system's repertoire of energy supplies.
 * @summary Creates a new supply within the system.
 */
export const createSupply = (
    createSupplyBody: CreateSupplyBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/v1/supplies`,
      createSupplyBody,options
    );
  }



export const getCreateSupplyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSupply>>, TError,{data: CreateSupplyBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createSupply>>, TError,{data: CreateSupplyBody}, TContext> => {

const mutationKey = ['createSupply'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSupply>>, {data: CreateSupplyBody}> = (props) => {
          const {data} = props ?? {};

          return  createSupply(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSupplyMutationResult = NonNullable<Awaited<ReturnType<typeof createSupply>>>
    export type CreateSupplyMutationBody = CreateSupplyBody
    export type CreateSupplyMutationError = AxiosError<unknown>

    /**
 * @summary Creates a new supply within the system.
 */
export const useCreateSupply = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSupply>>, TError,{data: CreateSupplyBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSupply>>,
        TError,
        {data: CreateSupplyBody},
        TContext
      > => {

      const mutationOptions = getCreateSupplyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * This endpoint facilitates the creation of a set of supplies within the system by importing a CSV file.

This endpoint requires clients to send a request containing a file with essential details for each supply, including code, address, users and any additional relevant information.

Authentication is mandated, utilizing an authentication token, to ensure secure access.

Upon successful file processing, the server responds with an HTTP status code of 200, along with comprehensive details about the result of the bulk operation, including what users have been created or any potential error.

In cases where the creation process encounters errors, the server responds with an appropriate error status code, accompanied by a descriptive error message to guide clients in addressing and resolving the issue.

 * @summary Creates supplies in bulk importing a CSV file.
 */
export const createSuppliesWithFile = (
    createSuppliesWithFileBody: CreateSuppliesWithFileBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreateSuppliesInBulkResponse>> => {
    
    const formData = new FormData();
formData.append(`file`, createSuppliesWithFileBody.file)

    return axios.default.post(
      `/api/v1/supplies/import`,
      formData,options
    );
  }



export const getCreateSuppliesWithFileMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSuppliesWithFile>>, TError,{data: CreateSuppliesWithFileBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createSuppliesWithFile>>, TError,{data: CreateSuppliesWithFileBody}, TContext> => {

const mutationKey = ['createSuppliesWithFile'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSuppliesWithFile>>, {data: CreateSuppliesWithFileBody}> = (props) => {
          const {data} = props ?? {};

          return  createSuppliesWithFile(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSuppliesWithFileMutationResult = NonNullable<Awaited<ReturnType<typeof createSuppliesWithFile>>>
    export type CreateSuppliesWithFileMutationBody = CreateSuppliesWithFileBody
    export type CreateSuppliesWithFileMutationError = AxiosError<unknown>

    /**
 * @summary Creates supplies in bulk importing a CSV file.
 */
export const useCreateSuppliesWithFile = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSuppliesWithFile>>, TError,{data: CreateSuppliesWithFileBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSuppliesWithFile>>,
        TError,
        {data: CreateSuppliesWithFileBody},
        TContext
      > => {

      const mutationOptions = getCreateSuppliesWithFileMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * This endpoint enables users to synchronize all active supplies retrieving the information from datadis.es. Proper authentication, through an authentication token, is required for secure access to this endpoint. A successful request returns an HTTP status code of 200. In cases of errors, the server responds with an appropriate error status code accompanied by a descriptive message to guide users in resolving any issues.
 * @summary Synchronize supplies retrieving the information from datadis.es.
 */
export const syncDatadisSupplies = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/v1/supplies/datadis/sync`,undefined,options
    );
  }



export const getSyncDatadisSuppliesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof syncDatadisSupplies>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof syncDatadisSupplies>>, TError,void, TContext> => {

const mutationKey = ['syncDatadisSupplies'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncDatadisSupplies>>, void> = () => {
          

          return  syncDatadisSupplies(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SyncDatadisSuppliesMutationResult = NonNullable<Awaited<ReturnType<typeof syncDatadisSupplies>>>
    
    export type SyncDatadisSuppliesMutationError = AxiosError<unknown>

    /**
 * @summary Synchronize supplies retrieving the information from datadis.es.
 */
export const useSyncDatadisSupplies = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof syncDatadisSupplies>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof syncDatadisSupplies>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getSyncDatadisSuppliesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    