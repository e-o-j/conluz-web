/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Conluz API
 * Conluz is an API-driven application designed for the efficient management of an energy community,enabling the administration of community members and their corresponding supply points and the retrieval of consumption, production data.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  CreateUserBody,
  CreateUsersInBulkResponse,
  CreateUsersWithFileBody,
  GetAllUsersParams,
  PagedResultUserResponse,
  UpdateUserBody,
  UserResponse
} from '.././models';





/**
 * This endpoint enables the update of user information by specifying the user's unique identifier in the endpoint path.

Clients send a request containing the updated user details, and authentication, through an authentication token, is required for secure access.

A successful update results in an HTTP status code of 200, indicating that the user information has been successfully modified. In cases where the update encounters errors, the server responds with an appropriate error status code along with a descriptive error message to assist clients in addressing and resolving the issue.

If you don't provide some of the optional parameters, they will be considered as null value so their values will be updated with a null value.
 * @summary Updates user information
 */
export const updateUser = (
    id: string,
    updateUserBody: UpdateUserBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse>> => {
    
    
    return axios.default.put(
      `/api/v1/users/${id}`,
      updateUserBody,options
    );
  }



export const getUpdateUserMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{id: string;data: UpdateUserBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{id: string;data: UpdateUserBody}, TContext> => {

const mutationKey = ['updateUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {id: string;data: UpdateUserBody}> = (props) => {
          const {id,data} = props ?? {};

          return  updateUser(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = UpdateUserBody
    export type UpdateUserMutationError = AxiosError<unknown>

    /**
 * @summary Updates user information
 */
export const useUpdateUser = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{id: string;data: UpdateUserBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {id: string;data: UpdateUserBody},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 *     This endpoint enables the removal of a user from the system by specifying the user's unique identifier within the endpoint path.

    To utilize this endpoint, clients send a DELETE request with the targeted user's ID, requiring authentication for secure access.

    Upon successful deletion, the server responds with an HTTP status code of 200, indicating that the user has been successfully removed.

    In cases where the deletion process encounters errors, the server returns an appropriate error status code, along with a descriptive error message to guide clients in diagnosing and addressing the issue.

 * @summary Removes a user by ID
 */
export const deleteUser = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/v1/users/${id}`,options
    );
  }



export const getDeleteUserMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteUser(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    
    export type DeleteUserMutationError = AxiosError<unknown>

    /**
 * @summary Removes a user by ID
 */
export const useDeleteUser = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUser>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * This endpoint facilitates the retrieval of all users within the system, allowing clients to access a comprehensive list of user details. Users can include optional query parameters, such as page to specify the page number, limit to determine the number of users per page, filter for selective retrieval based on specific criteria, and sort to define the order of the results. Proper authentication, through an authentication token, is required for secure access to this endpoint. A successful request returns an HTTP status code of 200, along with a paginated list of user details, providing valuable information such as unique identifiers, usernames, and creation timestamps. In case of issues, the server responds with an appropriate error status code, accompanied by a descriptive error message to guide clients in addressing any problems encountered during the retrieval process.
 * @summary Retrieves all registered users in the system with support for pagination, filtering, and sorting.
 */
export const getAllUsers = (
    params?: GetAllUsersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PagedResultUserResponse>> => {
    
    
    return axios.default.get(
      `/api/v1/users`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetAllUsersQueryKey = (params?: GetAllUsersParams,) => {
    return [`/api/v1/users`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAllUsersQueryOptions = <TData = Awaited<ReturnType<typeof getAllUsers>>, TError = AxiosError<unknown>>(params?: GetAllUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllUsers>>> = ({ signal }) => getAllUsers(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getAllUsers>>>
export type GetAllUsersQueryError = AxiosError<unknown>


export function useGetAllUsers<TData = Awaited<ReturnType<typeof getAllUsers>>, TError = AxiosError<unknown>>(
 params: undefined |  GetAllUsersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllUsers>>,
          TError,
          Awaited<ReturnType<typeof getAllUsers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllUsers<TData = Awaited<ReturnType<typeof getAllUsers>>, TError = AxiosError<unknown>>(
 params?: GetAllUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllUsers>>,
          TError,
          Awaited<ReturnType<typeof getAllUsers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllUsers<TData = Awaited<ReturnType<typeof getAllUsers>>, TError = AxiosError<unknown>>(
 params?: GetAllUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves all registered users in the system with support for pagination, filtering, and sorting.
 */

export function useGetAllUsers<TData = Awaited<ReturnType<typeof getAllUsers>>, TError = AxiosError<unknown>>(
 params?: GetAllUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllUsersQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * This endpoint facilitates the creation of a new user within the system.

This endpoint requires clients to send a request containing essential user details, including username, password, and any additional relevant information.

Authentication is mandated, utilizing an authentication token, to ensure secure access.

Upon successful user creation, the server responds with an HTTP status code of 200, along with comprehensive details about the newly created user, such as a unique identifier and username.

In cases where the creation process encounters errors, the server responds with an appropriate error status code, accompanied by a descriptive error message to guide clients in addressing and resolving the issue.

 * @summary Creates a new user within the system.
 */
export const createUser = (
    createUserBody: CreateUserBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse>> => {
    
    
    return axios.default.post(
      `/api/v1/users`,
      createUserBody,options
    );
  }



export const getCreateUserMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext> => {

const mutationKey = ['createUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {data: CreateUserBody}> = (props) => {
          const {data} = props ?? {};

          return  createUser(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = CreateUserBody
    export type CreateUserMutationError = AxiosError<unknown>

    /**
 * @summary Creates a new user within the system.
 */
export const useCreateUser = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createUser>>,
        TError,
        {data: CreateUserBody},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * This endpoint serves the purpose of enabling a previously disabled user within the system, with the user's unique identifier specified in the endpoint path.

Proper authentication, through an authentication token, is required for secure access.

Upon a successful request, the server responds with an HTTP status code of 200, indicating that the user has been successfully enabled.

This endpoint provides a crucial mechanism for restoring user access or lifting restrictions, supporting effective user management.

In situations where the enabling process encounters errors, the server responds with an appropriate error status code, accompanied by a descriptive error message to assist clients in diagnosing and resolving the issue.
 * @summary Enables a user by ID
 */
export const disableUser = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.post(
      `/api/v1/users/${id}/enable`,undefined,options
    );
  }



export const getDisableUserMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disableUser>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof disableUser>>, TError,{id: string}, TContext> => {

const mutationKey = ['disableUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof disableUser>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  disableUser(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DisableUserMutationResult = NonNullable<Awaited<ReturnType<typeof disableUser>>>
    
    export type DisableUserMutationError = AxiosError<unknown>

    /**
 * @summary Enables a user by ID
 */
export const useDisableUser = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disableUser>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof disableUser>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDisableUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 *     This endpoint is designed to disable a user within the system by specifying the user's unique identifier in the endpoint path.

    This operation requires proper authentication, through an authentication token, to ensure secure access.

    Upon a successful request, the server responds with an HTTP status code of 200, indicating that the user has been disabled.

    The endpoint provides an effective means to temporarily suspend user accounts or restrict access, crucial for security and user management purposes.

    In cases where the disablement encounters errors, the server returns an appropriate error status code along with a descriptive error message to guide clients in addressing and resolving the issue.

 * @summary Disables a user by ID
 */
export const disableUser1 = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.post(
      `/api/v1/users/${id}/disable`,undefined,options
    );
  }



export const getDisableUser1MutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disableUser1>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof disableUser1>>, TError,{id: string}, TContext> => {

const mutationKey = ['disableUser1'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof disableUser1>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  disableUser1(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DisableUser1MutationResult = NonNullable<Awaited<ReturnType<typeof disableUser1>>>
    
    export type DisableUser1MutationError = AxiosError<unknown>

    /**
 * @summary Disables a user by ID
 */
export const useDisableUser1 = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disableUser1>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof disableUser1>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDisableUser1MutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * This endpoint facilitates the creation of a set of users within the system by importing a CSV file.

This endpoint requires clients to send a request containing a file with essential details for each user, including username, password, and any additional relevant information.

Authentication is mandated, utilizing an authentication token, to ensure secure access.

Upon successful file processing, the server responds with an HTTP status code of 200, along with comprehensive details about the result of the bulk operation, including what users have been created or any potential error.

In cases where the creation process encounters errors, the server responds with an appropriate error status code, accompanied by a descriptive error message to guide clients in addressing and resolving the issue.

 * @summary Creates users in bulk importing a CSV file.
 */
export const createUsersWithFile = (
    createUsersWithFileBody: CreateUsersWithFileBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreateUsersInBulkResponse>> => {
    
    const formData = new FormData();
formData.append(`file`, createUsersWithFileBody.file)

    return axios.default.post(
      `/api/v1/users/import`,
      formData,options
    );
  }



export const getCreateUsersWithFileMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUsersWithFile>>, TError,{data: CreateUsersWithFileBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createUsersWithFile>>, TError,{data: CreateUsersWithFileBody}, TContext> => {

const mutationKey = ['createUsersWithFile'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUsersWithFile>>, {data: CreateUsersWithFileBody}> = (props) => {
          const {data} = props ?? {};

          return  createUsersWithFile(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUsersWithFileMutationResult = NonNullable<Awaited<ReturnType<typeof createUsersWithFile>>>
    export type CreateUsersWithFileMutationBody = CreateUsersWithFileBody
    export type CreateUsersWithFileMutationError = AxiosError<unknown>

    /**
 * @summary Creates users in bulk importing a CSV file.
 */
export const useCreateUsersWithFile = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUsersWithFile>>, TError,{data: CreateUsersWithFileBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createUsersWithFile>>,
        TError,
        {data: CreateUsersWithFileBody},
        TContext
      > => {

      const mutationOptions = getCreateUsersWithFileMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    